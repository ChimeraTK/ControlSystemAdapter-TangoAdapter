/*----- PROTECTED REGION ID(AdapterDeviceClass.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        AdapterDeviceClass.cpp
//
// description : C++ source for the AdapterDeviceClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the AdapterDeviceImpl once per process.
//
// project :
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include "AdapterDeviceClass.h"
#include "TangoAdapter.h"
#include "TangoLogCompat.h"

#include <algorithm>
#include <regex>

/*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass.cpp

//-------------------------------------------------------------------
/**
 *	Create AdapterDeviceClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)
#endif
// Naming is for Tango
// NOLINTNEXTLINE(readability-identifier-naming)
Tango::DeviceClass* _create_AdapterDeviceImpl_class([[maybe_unused]] const char* name) {
  // FIXME: Do we need to support this? It's for using this class in pytango
  assert(false);
  return nullptr;
}
}

namespace TangoAdapter {
  // Apply some heuristics to derive the class name from the executable name
  std::string AdapterDeviceClass::getClassName() {
    std::string ourName{Tango::Util::instance()->get_ds_exec_name()};

    std::regex start{"^ds_?"};
    std::regex end{"_?ds$"};

    ourName = std::regex_replace(ourName, start, "");
    ourName = std::regex_replace(ourName, end, "");

    TANGO_LOG_DEBUG << "Deriving class name from executable name: " << Tango::Util::instance()->get_ds_exec_name()
                    << " -> " << ourName << std::endl;

    return ourName;
  }

  //--------------------------------------------------------
  /**
   * method : 		AdapterDeviceClass::AdapterDeviceClass(std::string &s)
   * description : 	constructor for the AdapterDeviceClass
   *
   * @param s	The class name
   */
  //--------------------------------------------------------
  AdapterDeviceClass::AdapterDeviceClass(std::string& s) : Tango::DeviceClass(s) {
    TANGO_LOG_DEBUG << "Entering AdapterDeviceClass constructor" << std::endl;
    set_default_property();
    write_class_property();

    /*----- PROTECTED REGION ID(AdapterDeviceClass::constructor) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::constructor

    TANGO_LOG_DEBUG << "Leaving AdapterDeviceClass constructor" << std::endl;
  }

  //===================================================================
  //	Command execution method calls
  //===================================================================

  //===================================================================
  //	Properties management
  //===================================================================

  Tango::DbDatum AdapterDeviceClass::getPropertyWithDefault(
      const Tango::DbData& list, const std::string& propertyName) {
    const auto& position = std::find_if(list.begin(), list.end(), [&](auto x) { return x.name == propertyName; });
    if(position != list.end()) {
      return *position;
    }

    return {name};
  }
  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::get_class_property()
   *	Description : Get the class property for specified name.
   */
  //--------------------------------------------------------
  Tango::DbDatum AdapterDeviceClass::get_class_property(std::string& prop_name) {
    return getPropertyWithDefault(cl_prop, prop_name);
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::get_default_device_property()
   *	Description : Return the default value for device property.
   */
  //--------------------------------------------------------
  Tango::DbDatum AdapterDeviceClass::get_default_device_property(std::string& prop_name) {
    return getPropertyWithDefault(dev_def_prop, prop_name);
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::get_default_class_property()
   *	Description : Return the default value for class property.
   */
  /*------------------------------------------------------------------------------------------------------------------*/
  Tango::DbDatum AdapterDeviceClass::get_default_class_property(std::string& prop_name) {
    return getPropertyWithDefault(cl_def_prop, prop_name);
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::set_default_property()
   *	Description : Set default property (class and device) for wizard.
   *                For each property, add to wizard property name and description.
   *                If default value has been set, add it to wizard property and
   *                store it in a DbDatum.
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::set_default_property() {
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::write_class_property()
   *	Description : Set class description fields as property in database
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::write_class_property() {
    //	First time, check if database used
    if(!Tango::Util::_UseDb) {
      return;
    }

    Tango::DbData data;
    std::string classname = get_name();

    auto ourClass = ChimeraTK::TangoAdapter::getInstance().getMapper().getClass(get_name());
    assert(ourClass);


    //	Put title
    Tango::DbDatum title("ProjectTitle");
    std::vector<std::string> str_title{ourClass->title.value_or(ourClass->name)};
    title << str_title;
    data.push_back(title);

    //	Put Description
    Tango::DbDatum description("Description");
    std::vector<std::string> str_desc;
    str_desc.emplace_back(ourClass->description.value_or("ChimeraTK-based DeviceServer"));
    description << str_desc;
    data.push_back(description);

    //  Put inheritance
    Tango::DbDatum inher_datum("InheritedFrom");
    std::vector<std::string> inheritance;
    inheritance.emplace_back("TANGO_BASE_CLASS");
    inher_datum << inheritance;
    data.push_back(inher_datum);

    //	Call database and and values
    get_db_class()->put_property(data);
  }

  //===================================================================
  //	Factory methods
  //===================================================================

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::device_factory()
   *	Description : Create the device object(s)
   *                and store them in the device list
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::device_factory(const Tango::DevVarStringArray* devlist_ptr) {
    /*----- PROTECTED REGION ID(AdapterDeviceClass::device_factory_before) ENABLED START -----*/

    //	Add your own code

    auto& adapter = ChimeraTK::TangoAdapter::getInstance();
    auto& mapper = adapter.getMapper();

    auto deviceClass = mapper.getClass(get_name());

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::device_factory_before

    //	Create devices and add it into the device list
    for(unsigned int i = 0; i < devlist_ptr->length(); i++) {
      const auto *deviceName = (*devlist_ptr)[i].in();

      auto device = std::make_unique<AdapterDeviceImpl>(this, deviceName);
      device->init_device();
      if(!deviceClass->hasDevice(deviceName) &&
          !deviceClass->hasDevice(ChimeraTK::TangoAdapter::PLAIN_IMPORT_DUMMY_DEVICE.data())) {
        // See if we have the "generic" device"
        DEV_ERROR_STREAM(device) << "Device " << deviceName << "not known in attribute mapper. Expect issues" << std::endl;
        device->set_state(Tango::FAULT);
        device->set_status("Device was not found in mapping file, no variables could be mapped.");
      }
      else {
        // Move the generic device we have to this device.
        if(!deviceClass->hasDevice(deviceName)) {
          auto genericDevice =
              deviceClass->devicesInDeviceClass[ChimeraTK::TangoAdapter::PLAIN_IMPORT_DUMMY_DEVICE.data()];
          deviceClass->devicesInDeviceClass.erase(ChimeraTK::TangoAdapter::PLAIN_IMPORT_DUMMY_DEVICE.data());
          genericDevice->name = deviceName;
          deviceClass->devicesInDeviceClass[deviceName] = genericDevice;
        }
        device->attachToClassAttributes(deviceClass);
      }

      // Check before if database used.
      if(Tango::Util::_UseDb && !Tango::Util::_FileDb) {
        export_device(device.get());
      }
      else {
        export_device(device.get(), deviceName);
      }

      // Hand over device pointer to Tango
      device_list.push_back(device.release());
    }

    //	Manage dynamic attributes if any
    erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

    for(auto* dev : device_list) {
      // Only set the device state ok ON if it is still in the default constructed
      // value
      if(dev->get_state() == Tango::UNKNOWN) {
        dev->set_state(Tango::ON);
        dev->set_status("Application is running.");
      }
    }

    /*----- PROTECTED REGION ID(AdapterAdapterDeviceClass::device_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	AdapterAdapterDeviceClass::device_factory_after
  }
  /*------------------------------------------------------------------------------------------------------------------*/
  /**
   *	Method      : AdapterDeviceClass::attribute_factory()
   *	Description : Create the attribute object(s)
   *                and store them in the attribute list
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::attribute_factory([[maybe_unused]] std::vector<Tango::Attr*>& att_list) {
    /*----- PROTECTED REGION ID(AdapterDeviceClass::attribute_factory_before) ENABLED START -----*/

    //	Add your own code

    auto& adapter = ChimeraTK::TangoAdapter::getInstance();
    auto& mapper = adapter.getMapper();

    auto deviceClass = mapper.getClass(get_name());

    for(auto& attDesc : deviceClass->attributes) {
      att_list.push_back(attDesc.toTangoAttribute().release());
    }

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::attribute_factory_before

    //	Create a list of static attributes
    create_static_attribute_list(get_class_attr()->get_attr_list());
    /*----- PROTECTED REGION ID(AdapterDeviceClass::attribute_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	AdapterAdapterDeviceClass::attribute_factory_after
  }
  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::pipe_factory()
   *	Description : Create the pipe object(s)
   *                and store them in the pipe list
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::pipe_factory() {
    /*----- PROTECTED REGION ID(AdapterDeviceClass::pipe_factory_before) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::pipe_factory_before
    /*----- PROTECTED REGION ID(AdapterDeviceClass::pipe_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::pipe_factory_after
  }
  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceClass::command_factory()
   *	Description : Create the command object(s)
   *                and store them in the command list
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::command_factory() {
    /*----- PROTECTED REGION ID(AdapterDeviceClass::command_factory_before) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::command_factory_before

    /*----- PROTECTED REGION ID(AdapterDeviceClass::command_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::command_factory_after
  }

  //===================================================================
  //	Dynamic attributes related methods
  //===================================================================

  //--------------------------------------------------------
  /**
   * method : 		AdapterDeviceClass::create_static_attribute_list
   * description : 	Create the a list of static attributes
   *
   * @param	att_list	the ceated attribute list
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::create_static_attribute_list(std::vector<Tango::Attr*>& att_list) {
    for(auto* attr : att_list) {
      auto att_name = attr->get_name();
      std::transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
      defaultAttList.push_back(att_name);
    }

    TANGO_LOG_DEBUG << defaultAttList.size() << " attributes in default list" << std::endl;

    /*----- PROTECTED REGION ID(AdapterDeviceClass::create_static_att_list) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::create_static_att_list
  }

  //--------------------------------------------------------
  /**
   * method : 		AdapterDeviceClass::erase_dynamic_attributes
   * description : 	delete the dynamic attributes if any.
   *
   * @param	devlist_ptr	the device list pointer
   * @param	list of all attributes
   */
  //--------------------------------------------------------
  void AdapterDeviceClass::erase_dynamic_attributes(
      const Tango::DevVarStringArray* devlist_ptr, std::vector<Tango::Attr*>& att_list) {
    Tango::Util* tg = Tango::Util::instance();

    for(_CORBA_ULong i = 0; i < devlist_ptr->length(); i++) {
      auto* dev_impl = tg->get_device_by_name((std::string((*devlist_ptr)[i]).c_str()));
      auto* dev = dynamic_cast<AdapterDeviceImpl*>(dev_impl);
      assert(dev != nullptr);

      std::vector<Tango::Attribute*>& dev_att_list = dev->get_device_attr()->get_attribute_list();
      std::vector<Tango::Attribute*>::iterator ite_att;
      for(ite_att = dev_att_list.begin(); ite_att != dev_att_list.end(); ++ite_att) {
        std::string att_name((*ite_att)->get_name_lower());
        if((att_name == "state") || (att_name == "status")) {
          continue;
        }
        auto ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
        if(ite_str == defaultAttList.end()) {
          TANGO_LOG_DEBUG << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << std::endl;
          Tango::Attribute& att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
          dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
          --ite_att;
        }
      }
    }
    /*----- PROTECTED REGION ID(AdapterDeviceClass::erase_dynamic_attributes) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::erase_dynamic_attributes
  }


  /*----- PROTECTED REGION ID(AdapterDeviceClass::Additional Methods) ENABLED START -----*/

  /*----- PROTECTED REGION END -----*/ //	AdapterDeviceClass::Additional Methods
} // namespace TangoAdapter
