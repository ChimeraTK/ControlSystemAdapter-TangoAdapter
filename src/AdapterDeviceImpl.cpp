/*----- PROTECTED REGION ID(AdapterDeviceImpl.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        AdapterDeviceImpl.cpp
//
// description : C++ source for the AdapterDeviceImpl class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               AdapterDeviceImpl are implemented in this file.
//
// project :
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include "AdapterDeviceImpl.h"

#include "AdapterDeviceClass.h"
#include "AttributeProperty.h"
#include "TangoAdapter.h"

#include <ChimeraTK/Utilities.h>

#include <AttributeProperty.h>
#include <filesystem>

namespace detail {
  template<typename TangoType, typename AdapterType>
  void writeInitialSpectrumValue(Tango::DeviceImpl* device, const std::string& memoriedValue,
      Tango::WAttribute& writeAttribute, Tango::Attr& attr) {
    // StringToArray will create a std::vector<bool> which is an optimised version of std::vector
    // But Tango needs a plain array of bool, so we have to convert it here.
    if constexpr(std::is_same_v<Tango::DevBoolean, TangoType>) {
      auto values = ChimeraTK::stringToArray<TangoType>(memoriedValue);
      // No lint, we cannot use std::array here because we do not know the size at compile time
      // NOLINTNEXTLINE(modernize-avoid-c-arrays)
      auto data = std::make_unique<Tango::DevBoolean[]>(values.size());
      std::copy(values.begin(), values.end(), data.get());

      // We can pass in the unique pointer here, set_write_value will copy the data
      writeAttribute.set_write_value(data.get(), values.size());
    }
    else if constexpr(std::is_same_v<Tango::DevString, TangoType>) {
      auto values = ChimeraTK::stringToArray<std::string>(memoriedValue);
      // No lint, we cannot use std::array here because we do not know the size at compile time
      // NOLINTNEXTLINE(modernize-avoid-c-arrays)
      auto data = std::make_unique<Tango::DevString[]>(values.size());
      std::transform(values.begin(), values.end(), data.get(), [&](auto& v) {
        // NOLINTNEXTLINE
        return const_cast<char*>(v.c_str());
      });

      // We can pass in the unique pointer and c_str() here, set_write_value will copy the data
      // Lint: long is required by the Tango API
      // NOLINTNEXTLINE(google-runtime-int)
      writeAttribute.set_write_value(data.get(), static_cast<long>(values.size()));
    }
    else {
      auto values = ChimeraTK::stringToArray<TangoType>(memoriedValue);
      writeAttribute.set_write_value(values.data(), values.size());
    }

    attr.write(device, writeAttribute);
  }
} // namespace detail

/*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl.cpp

/**
 *  AdapterDeviceImpl class description:
 *    Test of TangoAdapterfor ChimeraTK
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//================================================================

namespace TangoAdapter {
  /*----- PROTECTED REGION ID(AdapterDeviceImpl::namespace_starting) ENABLED START -----*/

  //	static initializations

  /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::namespace_starting

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::AdapterDeviceImpl()
   *	Description : Constructors for a Tango device
   *                implementing the classAdapterDeviceImpl
   */
  //--------------------------------------------------------
  AdapterDeviceImpl::AdapterDeviceImpl(Tango::DeviceClass* cl, std::string& s) : TANGO_BASE_CLASS(cl, s.c_str()) {
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::constructor_1) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::constructor_1
  }
  //--------------------------------------------------------
  AdapterDeviceImpl::AdapterDeviceImpl(Tango::DeviceClass* cl, const char* s) : TANGO_BASE_CLASS(cl, s) {
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::constructor_2) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::constructor_2
  }
  //--------------------------------------------------------
  AdapterDeviceImpl::AdapterDeviceImpl(Tango::DeviceClass* cl, const char* s, const char* d)
  : TANGO_BASE_CLASS(cl, s, d) {
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::constructor_3) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::constructor_3
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::delete_device()
   *	Description : will be called at device destruction or at init command
   */
  //--------------------------------------------------------
  void AdapterDeviceImpl::delete_device() {
    DEBUG_STREAM << "AdapterDeviceImpl::delete_device() " << device_name << std::endl;
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::delete_device) ENABLED START -----*/

    DEBUG_STREAM << AdapterDeviceClass::getClassName() << ": TangoAdapter::~TangoAdapter" << std::endl;

    // detach_dynamic_attributes_from_device();
    //  Attention to stop application here but impossible
    //_appInstance->_applicationInstance.shutdown()();
    // std::for_each(_dynamic_attribute_list.begin(), _dynamic_attribute_list.end(), [](auto* p) { delete p; });
    //_dynamic_attribute_list.clear();

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::delete_device
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::init_device()
   *	Description : will be called at device initialization.
   */
  //--------------------------------------------------------
  void AdapterDeviceImpl::init_device() {
    DEBUG_STREAM << AdapterDeviceClass::getClassName() << ": AdapterDeviceImpl::init_device() create device "
                 << device_name << std::endl;
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::init_device_before) ENABLED START -----*/

    //	Initialization before get_device_property() call

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::init_device_before

    //	Get the device properties from database
    get_device_property();

    /*----- PROTECTED REGION ID(AdapterDeviceImpl::init_device) ENABLED START -----*/

    //	Initialize device

    auto& adapter = ChimeraTK::TangoAdapter::getInstance();
    if(!adapter.getError().empty()) {
      set_state(Tango::DevState::FAULT);
      set_status(adapter.getError());

      return;
    }

    // only need to write spectrum attributes (manual writing bug in Tango)
    // scalar attributes are memoried and initialized by Tango
    // But only if we are running with a database. If not, there is nothing to
    // restore anyway.

    DEBUG_STREAM << AdapterDeviceClass::getClassName() << ":ChimeraTKExample2::init_device() end of init_device "
                 << std::endl;

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::init_device
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::get_device_property()
   *	Description : Read database to initialize property data members.
   */
  //--------------------------------------------------------
  void AdapterDeviceImpl::get_device_property() {
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::get_device_property_before) ENABLED START -----*/

    //	Initialize property data members

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::get_device_property_before

    //	Read device properties from database.
    Tango::DbData dev_prop;
    dev_prop.emplace_back("AttributeList");
    dev_prop.emplace_back("WorkingFolder");

    //	is there at least one property to be read ?
    if(!dev_prop.empty()) {
      //	Call database and extract values
      if(Tango::Util::_UseDb) {
        get_db_device()->get_property(dev_prop);
      }

      //	get instance on AdapterDeviceClass to get class property
      Tango::DbDatum def_prop, cl_prop;
      auto* ds_class = dynamic_cast<AdapterDeviceClass*>(get_device_class());
      assert(ds_class != nullptr);
      int i = -1;

      //	Try to initialize AttributeList from class property
      cl_prop = ds_class->get_class_property(dev_prop[++i].name);
      if(!cl_prop.is_empty()) {
        cl_prop >> attributeList;
      }
      else {
        //	Try to initialize AttributList from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if(!def_prop.is_empty()) {
          def_prop >> attributeList;
        }
      }
      //	And try to extract AttributList value from database
      if(!dev_prop[i].is_empty()) {
        dev_prop[i] >> attributeList;
      }

      //	Try to initialize WorkingFolder from class property
      cl_prop = ds_class->get_class_property(dev_prop[++i].name);
      if(!cl_prop.is_empty()) {
        cl_prop >> workingFolder;
      }
      else {
        //	Try to initialize WorkingFolder from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if(!def_prop.is_empty()) {
          def_prop >> workingFolder;
        }
      }
      //	And try to extract WorkingFolder value from database
      if(!dev_prop[i].is_empty()) {
        dev_prop[i] >> workingFolder;
      }
    }

    /*----- PROTECTED REGION ID(AdapterDeviceImpl::get_device_property_after) ENABLED START -----*/

    //	Check device property data members init

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::get_device_property_after
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::always_executed_hook()
   *	Description : method always executed before any command is executed
   */
  //--------------------------------------------------------
  void AdapterDeviceImpl::always_executed_hook() {
    // DEBUG_STREAM << "AdapterDeviceImpl::always_executed_hook()  " << device_name << std::endl;
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::always_executed_hook) ENABLED START -----*/

    //	code always executed before all requests

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::always_executed_hook
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::read_attr_hardware()
   *	Description : Hardware acquisition for attributes
   */
  //--------------------------------------------------------
  void AdapterDeviceImpl::read_attr_hardware(TANGO_UNUSED(std::vector<long>& attr_list)) {
    // DEBUG_STREAM << "AdapterDeviceImpl::read_attr_hardware(vector<long> &attr_list) entering... " << std::endl;
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::read_attr_hardware) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::read_attr_hardware
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::add_dynamic_attributes()
   *	Description : Create the dynamic attributes if any
   *                for specified device.
   */
  //--------------------------------------------------------
  void AdapterDeviceImpl::add_dynamic_attributes() {
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::add_dynamic_attributes) ENABLED START -----*/

    //	Add your own code to create and add dynamic attributes if any

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::add_dynamic_attributes
  }

  //--------------------------------------------------------
  /**
   *	Method      : AdapterDeviceImpl::add_dynamic_commands()
   *	Description : Create the dynamic commands if any
   *                for specified device.
   */
  //--------------------------------------------------------
  void AdapterDeviceImpl::add_dynamic_commands() {
    /*----- PROTECTED REGION ID(AdapterDeviceImpl::add_dynamic_commands) ENABLED START -----*/

    //	Add your own code to create and add dynamic commands if any

    /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::add_dynamic_commands
  }

  /*----- PROTECTED REGION ID(AdapterDeviceImpl::namespace_ending) ENABLED START -----*/

  void AdapterDeviceImpl::write_inited_values(const std::list<ChimeraTK::AttributeProperty>& writeableSpectrums) {
    DEBUG_STREAM << AdapterDeviceClass::getClassName() << ": TangoAdapter::write_inited_values "
                 << writeableSpectrums.size() << std::endl;

    // read spectrum values from memoried properties then write as initialised values
    for(const auto& attProp : writeableSpectrums) {
      DEBUG_STREAM << AdapterDeviceClass::getClassName() << ":name: " << attProp.name << " type:" << attProp.dataType
                   << std::endl;
      // get write attribute name
      auto& write_attribute = get_device_attr()->get_w_attr_by_name(attProp.name.c_str());
      std::string attName = attProp.name;
      auto& baseAttribute = get_device_class()->get_class_attr()->get_attr(attName);
      // get value of memoried property (__Memorized_<attributename>)
      auto mem_value = ChimeraTK::getProperty<std::string>(this, "__Memoried_" + attProp.name);

      DEBUG_STREAM << AdapterDeviceClass::getClassName() << ":__Memoried_" << attProp.name
                   << " mem_value: " << mem_value << std::endl;

      if(mem_value.empty()) {
        continue;
      }

      switch(attProp.dataType) {
        case Tango::DEV_UCHAR: {
          ::detail::writeInitialSpectrumValue<Tango::DevUChar, uint8_t>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }

        case Tango::DEV_ENUM: {
          ::detail::writeInitialSpectrumValue<Tango::DevShort, int8_t>(this, mem_value, write_attribute, baseAttribute);
          break;
        }

        case Tango::DEV_USHORT: {
          ::detail::writeInitialSpectrumValue<Tango::DevUShort, uint16_t>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }
        case Tango::DEV_ULONG: {
          ::detail::writeInitialSpectrumValue<Tango::DevULong, uint32_t>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }
        case Tango::DEV_ULONG64: {
          ::detail::writeInitialSpectrumValue<Tango::DevULong64, uint64_t>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }

        case Tango::DEV_SHORT: {
          ::detail::writeInitialSpectrumValue<Tango::DevShort, int16_t>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }
        case Tango::DEV_LONG: {
          ::detail::writeInitialSpectrumValue<Tango::DevLong, int32_t>(this, mem_value, write_attribute, baseAttribute);
          break;
        }
        case Tango::DEV_LONG64: {
          ::detail::writeInitialSpectrumValue<Tango::DevLong64, int64_t>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }
        case Tango::DEV_FLOAT: {
          ::detail::writeInitialSpectrumValue<Tango::DevFloat, float>(this, mem_value, write_attribute, baseAttribute);
          break;
        }

        case Tango::DEV_DOUBLE: {
          ::detail::writeInitialSpectrumValue<Tango::DevDouble, double>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }
        case Tango::DEV_BOOLEAN: {
          ::detail::writeInitialSpectrumValue<Tango::DevBoolean, ChimeraTK::Boolean>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }
        case Tango::DEV_STRING: {
          ::detail::writeInitialSpectrumValue<Tango::DevString, std::string>(
              this, mem_value, write_attribute, baseAttribute);
          break;
        }
        default:
          ERROR_STREAM << AdapterDeviceClass::getClassName()
                       << ":TangoAdapter::write_inited_values - unknown datatype: " << attProp.dataType << std::endl;
      }
    }

    // check for variables not yet initialised - we must guarantee that all to-application variables are written exactly
    // once at server start.
    for(auto& pv : ChimeraTK::TangoAdapter::getInstance().getCsPvManager()->getAllProcessVariables()) {
      if(!pv->isWriteable()) {
        continue;
      }

      if(pv->getVersionNumber() == ChimeraTK::VersionNumber(nullptr)) {
        // The variable has not yet been written. Do it now, even if we just send a 0.
        pv->write();
      }
    }
  }

  /*----- PROTECTED REGION END -----*/ //	AdapterDeviceImpl::namespace_ending

  void AdapterDeviceImpl::attachToClassAttributes(
      const std::shared_ptr<ChimeraTK::AttributeMapper::DeviceClass>& deviceClass) {
    auto device = deviceClass->getDevice(get_name());
    auto& adapter = ChimeraTK::TangoAdapter::getInstance();
    auto csPvManager = adapter.getCsPvManager();
    std::list<ChimeraTK::AttributeProperty> writeableSpectrums;

    DEBUG_STREAM << "Attaching Variables to device instance " << device->name << std::endl;
    for(auto& attr : deviceClass->attributes) {
      auto& source = device->attributeToSource[attr.name];
      DEBUG_STREAM << "    " << source << std::endl;

      auto processVariable = csPvManager->getProcessVariable(source);
      auto pv = ChimeraTK::TransferElementAbstractor(processVariable);
      attributeToPvMap[attr.name] = pv;

      // Properly namespace the pv in the updater so we can distinguish per device
      adapter.getUpdater().addVariable(pv, get_name() + "/" + attr.name);

      if(attr.attrDataFormat == ChimeraTK::SPECTRUM &&
          (attr.writeType == Tango::WRITE || attr.writeType == Tango::READ_WRITE)) {
        writeableSpectrums.push_back(attr);
      }
    }

    if(Tango::Util::_UseDb) {
      write_inited_values(writeableSpectrums);
    }
  }
} // namespace TangoAdapter
