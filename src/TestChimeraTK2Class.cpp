/*----- PROTECTED REGION ID(TestChimeraTK2Class.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        TestChimeraTK2Class.cpp
//
// description : C++ source for the TestChimeraTK2Class.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the TestChimeraTK2 once per process.
//
// project :
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include "TestChimeraTK2Class.h"

#include <regex>

#ifndef cout4
#  define cout4 TANGO_LOG_DEBUG
#endif

#ifndef cout2
#  define cout2 TANGO_LOG_DEBUG
#endif

/*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class.cpp

//-------------------------------------------------------------------
/**
 *	Create TestChimeraTK2Class singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)
#endif

    Tango::DeviceClass* _create_TestChimeraTK2_class(const char* name) {
  return TestChimeraTK2_ns::TestChimeraTK2Class::init(name);
}
}

namespace TestChimeraTK2_ns {
  //===================================================================
  //	Initialize pointer for singleton pattern
  //===================================================================
  TestChimeraTK2Class* TestChimeraTK2Class::_instance = NULL;

  std::string TestChimeraTK2Class::getClassName() {
    std::string ourName{Tango::Util::instance()->get_ds_exec_name()};

    std::regex start{"^ds_?"};
    std::regex end{"_?ds$"};

    ourName = std::regex_replace(ourName, start, "");
    ourName = std::regex_replace(ourName, end, "");

    TANGO_LOG_DEBUG << "Deriving class name from executable name: " << Tango::Util::instance()->get_ds_exec_name()
                    << " -> " << ourName << std::endl;

    return ourName;
  }

  //--------------------------------------------------------
  /**
   * method : 		TestChimeraTK2Class::TestChimeraTK2Class(std::string &s)
   * description : 	constructor for the TestChimeraTK2Class
   *
   * @param s	The class name
   */
  //--------------------------------------------------------
  TestChimeraTK2Class::TestChimeraTK2Class(std::string& s) : Tango::DeviceClass(s) {
    cout2 << "Entering TestChimeraTK2Class constructor" << std::endl;
    set_default_property();
    write_class_property();

    /*----- PROTECTED REGION ID(TestChimeraTK2Class::constructor) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::constructor

    cout2 << "Leaving TestChimeraTK2Class constructor" << std::endl;
  }

  //--------------------------------------------------------
  /**
   * method : 		TestChimeraTK2Class::~TestChimeraTK2Class()
   * description : 	destructor for the TestChimeraTK2Class
   */
  //--------------------------------------------------------
  TestChimeraTK2Class::~TestChimeraTK2Class() {
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::destructor) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::destructor

    _instance = NULL;
  }

  //--------------------------------------------------------
  /**
   * method : 		TestChimeraTK2Class::init
   * description : 	Create the object if not already done.
   *                  Otherwise, just return a pointer to the object
   *
   * @param	name	The class name
   */
  //--------------------------------------------------------
  TestChimeraTK2Class* TestChimeraTK2Class::init(const char* name) {
    if(_instance == NULL) {
      try {
        std::string s(name);
        _instance = new TestChimeraTK2Class(s);
      }
      catch(std::bad_alloc&) {
        throw;
      }
    }
    return _instance;
  }

  //--------------------------------------------------------
  /**
   * method : 		TestChimeraTK2Class::instance
   * description : 	Check if object already created,
   *                  and return a pointer to the object
   */
  //--------------------------------------------------------
  TestChimeraTK2Class* TestChimeraTK2Class::instance() {
    if(_instance == NULL) {
      std::cerr << "Class is not initialised !!" << std::endl;
      exit(-1);
    }
    return _instance;
  }

  //===================================================================
  //	Command execution method calls
  //===================================================================

  //===================================================================
  //	Properties management
  //===================================================================
  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::get_class_property()
   *	Description : Get the class property for specified name.
   */
  //--------------------------------------------------------
  Tango::DbDatum TestChimeraTK2Class::get_class_property(std::string& prop_name) {
    for(unsigned int i = 0; i < cl_prop.size(); i++)
      if(cl_prop[i].name == prop_name) return cl_prop[i];
    //	if not found, returns  an empty DbDatum
    return Tango::DbDatum(prop_name);
  }

  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::get_default_device_property()
   *	Description : Return the default value for device property.
   */
  //--------------------------------------------------------
  Tango::DbDatum TestChimeraTK2Class::get_default_device_property(std::string& prop_name) {
    for(unsigned int i = 0; i < dev_def_prop.size(); i++)
      if(dev_def_prop[i].name == prop_name) return dev_def_prop[i];
    //	if not found, return  an empty DbDatum
    return Tango::DbDatum(prop_name);
  }

  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::get_default_class_property()
   *	Description : Return the default value for class property.
   */
  //--------------------------------------------------------
  Tango::DbDatum TestChimeraTK2Class::get_default_class_property(std::string& prop_name) {
    for(unsigned int i = 0; i < cl_def_prop.size(); i++)
      if(cl_def_prop[i].name == prop_name) return cl_def_prop[i];
    //	if not found, return  an empty DbDatum
    return Tango::DbDatum(prop_name);
  }

  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::set_default_property()
   *	Description : Set default property (class and device) for wizard.
   *                For each property, add to wizard property name and description.
   *                If default value has been set, add it to wizard property and
   *                store it in a DbDatum.
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::set_default_property() {
    std::string prop_name;
    std::string prop_desc;
    std::string prop_def;
    std::vector<std::string> vect_data;

    //	Set Default Class Properties

    //	Set Default device Properties
    prop_name = "AttributList";
    prop_desc = "AttributList";
    prop_def = "";
    vect_data.clear();
    if(prop_def.length() > 0) {
      Tango::DbDatum data(prop_name);
      data << vect_data;
      dev_def_prop.push_back(data);
      add_wiz_dev_prop(prop_name, prop_desc, prop_def);
    }
    else
      add_wiz_dev_prop(prop_name, prop_desc);
    prop_name = "DMapFilePath";
    prop_desc = "DMapFilePath";
    prop_def = "";
    vect_data.clear();
    if(prop_def.length() > 0) {
      Tango::DbDatum data(prop_name);
      data << vect_data;
      dev_def_prop.push_back(data);
      add_wiz_dev_prop(prop_name, prop_desc, prop_def);
    }
    else
      add_wiz_dev_prop(prop_name, prop_desc);
  }

  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::write_class_property()
   *	Description : Set class description fields as property in database
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::write_class_property() {
    //	First time, check if database used
    if(Tango::Util::_UseDb == false) return;

    Tango::DbData data;
    std::string classname = get_name();
    std::string header;
    std::string::size_type start, end;

    //	Put title
    Tango::DbDatum title("ProjectTitle");
    title << TestChimeraTK2Class::getClassName();
    data.push_back(title);

    //	Put Description
    Tango::DbDatum description("Description");
    std::vector<std::string> str_desc;
    str_desc.push_back("ChimeraTK-based DeviceServer");
    description << str_desc;
    data.push_back(description);

    //  Put inheritance
    Tango::DbDatum inher_datum("InheritedFrom");
    std::vector<std::string> inheritance;
    inheritance.push_back("TANGO_BASE_CLASS");
    inher_datum << inheritance;
    data.push_back(inher_datum);

    //	Call database and and values
    get_db_class()->put_property(data);
  }

  //===================================================================
  //	Factory methods
  //===================================================================

  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::device_factory()
   *	Description : Create the device object(s)
   *                and store them in the device list
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::device_factory(const Tango::DevVarStringArray* devlist_ptr) {
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::device_factory_before) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::device_factory_before

    //	Create devices and add it into the device list
    for(unsigned long i = 0; i < devlist_ptr->length(); i++) {
      cout4 << "Device name : " << (*devlist_ptr)[i].in() << std::endl;
      device_list.push_back(new TestChimeraTK2(this, (*devlist_ptr)[i]));
    }

    //	Manage dynamic attributes if any
    // erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

    //	Export devices to the outside world
    for(unsigned long i = 1; i <= devlist_ptr->length(); i++) {
      //	Add dynamic attributes if any
      TestChimeraTK2* dev = static_cast<TestChimeraTK2*>(device_list[device_list.size() - i]);
      dev->add_dynamic_attributes();

      //	Check before if database used.
      if((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
        export_device(dev);
      else
        export_device(dev, dev->get_name().c_str());
    }

    /*----- PROTECTED REGION ID(TestChimeraTK2Class::device_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::device_factory_after
  }
  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::attribute_factory()
   *	Description : Create the attribute object(s)
   *                and store them in the attribute list
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::attribute_factory(std::vector<Tango::Attr*>& att_list) {
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::attribute_factory_before) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::attribute_factory_before

    //	Create a list of static attributes
    create_static_attribute_list(get_class_attr()->get_attr_list());
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::attribute_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::attribute_factory_after
  }
  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::pipe_factory()
   *	Description : Create the pipe object(s)
   *                and store them in the pipe list
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::pipe_factory() {
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::pipe_factory_before) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::pipe_factory_before
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::pipe_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::pipe_factory_after
  }
  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::command_factory()
   *	Description : Create the command object(s)
   *                and store them in the command list
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::command_factory() {
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::command_factory_before) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::command_factory_before

    /*----- PROTECTED REGION ID(TestChimeraTK2Class::command_factory_after) ENABLED START -----*/

    //	Add your own code

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::command_factory_after
  }

  //===================================================================
  //	Dynamic attributes related methods
  //===================================================================

  //--------------------------------------------------------
  /**
   * method : 		TestChimeraTK2Class::create_static_attribute_list
   * description : 	Create the a list of static attributes
   *
   * @param	att_list	the ceated attribute list
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::create_static_attribute_list(std::vector<Tango::Attr*>& att_list) {
    for(unsigned long i = 0; i < att_list.size(); i++) {
      std::string att_name(att_list[i]->get_name());
      transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
      defaultAttList.push_back(att_name);
    }

    cout2 << defaultAttList.size() << " attributes in default list" << std::endl;

    /*----- PROTECTED REGION ID(TestChimeraTK2Class::create_static_att_list) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::create_static_att_list
  }

  //--------------------------------------------------------
  /**
   * method : 		TestChimeraTK2Class::erase_dynamic_attributes
   * description : 	delete the dynamic attributes if any.
   *
   * @param	devlist_ptr	the device list pointer
   * @param	list of all attributes
   */
  //--------------------------------------------------------
  void TestChimeraTK2Class::erase_dynamic_attributes(
      const Tango::DevVarStringArray* devlist_ptr, std::vector<Tango::Attr*>& att_list) {
    Tango::Util* tg = Tango::Util::instance();

    for(unsigned long i = 0; i < devlist_ptr->length(); i++) {
      Tango::DeviceImpl* dev_impl = tg->get_device_by_name(((std::string)(*devlist_ptr)[i]).c_str());
      TestChimeraTK2* dev = static_cast<TestChimeraTK2*>(dev_impl);

      std::vector<Tango::Attribute*>& dev_att_list = dev->get_device_attr()->get_attribute_list();
      std::vector<Tango::Attribute*>::iterator ite_att;
      for(ite_att = dev_att_list.begin(); ite_att != dev_att_list.end(); ++ite_att) {
        std::string att_name((*ite_att)->get_name_lower());
        if((att_name == "state") || (att_name == "status")) continue;
        std::vector<std::string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
        if(ite_str == defaultAttList.end()) {
          cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << std::endl;
          Tango::Attribute& att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
          dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
          --ite_att;
        }
      }
    }
    /*----- PROTECTED REGION ID(TestChimeraTK2Class::erase_dynamic_attributes) ENABLED START -----*/

    /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::erase_dynamic_attributes
  }

  //--------------------------------------------------------
  /**
   *	Method      : TestChimeraTK2Class::get_attr_object_by_name()
   *	Description : returns Tango::Attr * object found by name
   */
  //--------------------------------------------------------
  Tango::Attr* TestChimeraTK2Class::get_attr_object_by_name(std::vector<Tango::Attr*>& att_list, std::string attname) {
    std::vector<Tango::Attr*>::iterator it;
    for(it = att_list.begin(); it < att_list.end(); ++it)
      if((*it)->get_name() == attname) return (*it);
    //	Attr does not exist
    return NULL;
  }

  /*----- PROTECTED REGION ID(TestChimeraTK2Class::Additional Methods) ENABLED START -----*/

  /*----- PROTECTED REGION END -----*/ //	TestChimeraTK2Class::Additional Methods
} // namespace TestChimeraTK2_ns
